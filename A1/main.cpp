#include <fstream>
#include <iostream>
#include <chrono>
#include <thread>
#include <cstdlib>

using namespace std;
using namespace std::chrono;

auto start_time = high_resolution_clock::now();

    //This function sort (in ascending order) locations based on total time taken to go to the location from all other locations.
    //It also keep record of changed position of location in other array indexT.
    void Sort_ascending(int LocationInTime[], int indexT[], int l)
    {
        for (int i = 0; i < l - 1; ++i)
        {
            int strt = i;
            for (int j = i + 1; j < l; ++j)
            {
                if (LocationInTime[j] < LocationInTime[strt])
                    strt = j;
            }
            if (strt != i) {
                int temp = LocationInTime[i];
                LocationInTime[i] = LocationInTime[strt];
                LocationInTime[strt] = temp;
                int temp1 = indexT[i];
                indexT[i] = indexT[strt];
                indexT[strt] = temp1;
            }
        }
    }

    //This function sort (in descending order) zones based on total walks out from the zones to all other zones.
    //It also keep record of changed position of zones in other array indexN.
    void Sort_descending(int ZoneWalkout[], int indexN[], int z)
    {
        for (int i = 0; i < z - 1; ++i)
        {
            int strt = i;
            for (int j = i + 1; j < z; ++j)
            {
                if (ZoneWalkout[j] > ZoneWalkout[strt])
                    strt = j;
            }
            if (strt != i) {
                int temp = ZoneWalkout[i];
                ZoneWalkout[i] = ZoneWalkout[strt];
                ZoneWalkout[strt] = temp;
                int temp1 = indexN[i];
                indexN[i] = indexN[strt];
                indexN[strt] = temp1;
            }
        }
    }

    //Function to compute first state/allocation.
    //It allocate zone having highest total walkout to location having least total in time.
    void Get_starting_allocation(int mapping[], int z, int l, int **N, int **T, int indexT[])
    {
        int LocationInTime[l];

        for (int i=0; i<l; i++)
        {
            LocationInTime[i]=0;
            for(int j=0; j<l;j++)
            {
                LocationInTime[i]+=T[j][i];
            }
        }

        Sort_ascending(LocationInTime, indexT, l);

        int ZoneWalkout[z], indexN[z];

        for (int i=0; i<z; i++)
            indexN[i] = i+1;

        for (int i=0; i<z; i++)
        {
            ZoneWalkout[i]=0;
            for(int j=0; j<z;j++)
            {
                ZoneWalkout[i]+=N[i][j];
            }
        }

        Sort_descending (ZoneWalkout, indexN, z);

        for(int i=0;i<z;i++)
        {
            mapping[indexN[i]-1]=indexT[i];
        }
    }

    //Function to compute cost of given mapping/allocation.
    long long int cost_fn(int mapping[], int z, int l, int **N, int **T)
    {
        long long int cost=0;
        for(int i=0;i<z;i++)
            for(int j=0;j<z;j++)
            {
                cost+=(long long)N[i][j]*(long long)T[mapping[i]-1][mapping[j]-1];
            }
        return cost;
    }

    //Function to optimize allocation cost
    void Compute_allocation(long long int cost, int mapping[], int z, int l, int **N, int **T, float t, int indexT[])
    {   
        float t1 = (t*60)-1.0;
        auto target_duration = std::chrono::seconds(static_cast<int>(t1));
        while(true)
        {
            int FlagA=0;
            int NewMapping[z];
            int long long new_cost=0;

            for(int p=0; p<z; p++)
                NewMapping[p] = mapping[p];

            //Evaluate neighbours generated by interchanging zone positions
            for(int i=0;i<z;i++)
                for(int j=i+1;j<z;j++)
                {
                    int temp;
                    temp=NewMapping[i];
                    NewMapping[i]=NewMapping[j];
                    NewMapping[j]=temp;
                    new_cost=cost_fn(NewMapping, z, l, N, T);

                    if(new_cost<cost)
                    {
                        cost=new_cost;
                        j=z;
                        i=z;
                        FlagA=1;
                        for(int p=0;p<z;p++)
                            mapping[p] = NewMapping[p];
                    }
                    else
                    {
                    temp=NewMapping[i];
                    NewMapping[i]=NewMapping[j];
                    NewMapping[j]=temp;
                    }
                    auto current_time = std::chrono::high_resolution_clock::now();
                    auto elapsed_duration = std::chrono::duration_cast<std::chrono::seconds>(current_time - start_time);
                    if (elapsed_duration >= target_duration)
                        return ;
                }

            if(FlagA==0)
            {
                int NewMapping2[l];
                for(int p=0; p<z; p++)
                    NewMapping2[p] = mapping[p];
                for(int p=z; p<l; p++)
                    NewMapping2[p] = indexT[p];

                for(int i=0;i<z;i++)
                    for(int j=z;j<l;j++)
                    {
                        int temp=NewMapping2[i];
                        NewMapping2[i]=NewMapping2[j];
                        NewMapping2[j]=temp;
                        int long long new_cost=0;
                        new_cost=cost_fn(NewMapping2, z, l, N, T);

                        if(new_cost<cost)
                        {
                            cost=new_cost;
                            //cout << "Cost updated beyond z location";
                            j=l;
                            i=z;
                            for(int p=0;p<z;p++)
                                mapping[p] = NewMapping2[p];
                        }
                        else
                        {
                            temp=NewMapping2[i];
                            NewMapping2[i]=NewMapping2[j];
                            NewMapping2[j]=temp;
                        }
                        auto current_time = std::chrono::high_resolution_clock::now();
                        auto elapsed_duration = std::chrono::duration_cast<std::chrono::minutes>(current_time - start_time);
                        if (elapsed_duration >= target_duration)
                                return ;
                    }
            }
        }
    }

int main(int argc, char** argv)
{
    if (argc != 3) {
        cout << "Usage: " << argv[0] << " input_file output_file" << endl;
        return 1;
    }

    string ipfilename ( argv[1] );
    string outputFilename ( argv[2] );

    cout<<"Code is Executing. Please Wait ....\n";
    float t;
    int z, l;
    int **N, **T;
    fstream ipfile;
    //opening input file
    ipfile.open( ipfilename , ios::in);
    if (!ipfile)
    {
        cout << "No such file\n";
        exit(0);
    }
    else
    {
        ipfile >> t >> z >> l;
        if(z>l)
        {
            cout<<"Number of zones more than locations, check format of input file\n";
            exit(0);
        }
    }


    //Seeking Heap memory for Matrix N (zone)
    N = new int*[z];
    for (int i = 0; i < z; ++i)
        N[i] = new int[z];

    //Writing matrix N from input file
    for(int i=0;i<z;i++)
    {
        for(int j=0;j<z;j++)
        ipfile >> N[i][j];
    }

    //Diagonal elements of matrix N is set to zero intentionally for ensuring correct huristic calculation   
    for (int i=0; i<z; i++)
        N[i][i] = 0;


    //Seeking Heap memory for Matrix T (Location)
    T = new int*[l];
    for (int i = 0; i < l; ++i)
        T[i] = new int[l];

    //Writing matrix T from input file
    for(int i=0;i<l;i++)
    {
        for(int j=0;j<l;j++)
        ipfile >> T[i][j];
    }

    //closing the file
    ipfile.close();

    //mapping is output where zone allocation will be stored.
    int mapping[z];

    // indexT stores position of Location. E.g. indexT[0] means 1st location.
    int indexT[l];
    for (int i=0; i<l; i++)
            indexT[i] = i+1;

    //Getting our first starting state/allocation
    Get_starting_allocation(mapping, z, l, N, T, indexT);

    //Finding cost of first allocation
    long long int cost=0;
    cost = cost_fn(mapping, z, l, N, T);

    //Finding allocations with lower cost
    Compute_allocation(cost, mapping, z, l, N, T, t, indexT);

    //deleting heap memory
    delete T;
    delete N;

    ofstream outFile(outputFilename);
    // Check if the file is open
    if (!outFile.is_open())
    {
        cout << "Unable to open file for writing\n" ;
        return 1;
    }
    // Write data from the mapping to the output file
    for (int i = 0; i < z; i++)
        outFile << mapping[i] << " ";

    // Close the file
    outFile.close();

    cout<<"Execution Done. Check output file.\n";

    return 0;
}
